找出旋转后的数组的最小数字(二分法） 1.使用二分法，分到分无可分，由于是半升序，最小值一定在最左边指向的地方，因此二分法最后输出分段后的左部分。
剑指 Offer 11.旋转数组的最小数字
更新于 2022-01-08 22:13
数组中重复数字（哈希表） 1.用HashSet 遍历每个数字并加入几何，如果已经在集合内就说明重复，返回，否则就添加进去。 Set<Integer> dic = new HashSet<>(); for(int num : nums) { if(dic.contains(num)) return num; dic.add(num); } return -1; }
剑指 Offer 03.数组中重复的数字
更新于 2022-01-08 21:56
连续子数组最大和（动态规划，分治，重点难点） 1.动态规划 f(i)是第i个数结尾的连续子数组的最大和，不管前面几个数，总之是和最大的。 int pre = 0, maxAns = nums[0]; for (int x : nums) { pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); } return maxAns; } 2.分治 对于一个区间 [l,r][l,r]，我们可以维护四个量： \textit{lSum}lSum 表示 [l,r][l,r] 内以 ll 为左端点的最大子段和 \textit{rSum}rSum 表示 [l,r][l,r] 内以 rr 为右端点的最大子段和 \textit{mSum}mSum 表示 [l,r][l,r] 内的最大子段和 \textit{iSum}iSum 表示 [l,r][l,r] 的区间和 对于长度大于 11 的区间： 首先最好维护的是 iSum，区间 [l,r] 的 iSum 就等于「左子区间」的 iSum 加上「右子区间」的iSum。 对于 [l,r] 的 lSum，存在两种可能，它要么等于「左子区间」的 lSum，要么等于「左子区间」的 iSum 加上「右子区间」的 lSum，二者取大。 对于 [l,r] 的 }rSum，同理，它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，二者取大。 当计算好上面的三个量之后，就很好计算 [l,r] 的 mSum 了。我们可以考虑 [l,r]的 mSum 对应的区间是否跨越 m——它可能不跨越 m，也就是说 [l,r]的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 m，可能是「左子区间」rSum 和 「右子区间」的lSum 求和。三者取大。
剑指 Offer 42.连续子数组的最大和
更新于 2022-01-08 21:52
取出数组最小的k个数（排序，快速排序，堆） 1.内置函数排序 Arrays.sort(arr) 2.堆 把前k个数建堆，大根堆（优先队列，最小堆性质，堆顶是最小的）。然后遍历从第k+1个开始，如果有比堆顶更小的，弹出堆顶。遍历完成后将大根堆内数存入数组即可。 建立空堆：PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>() { public int compare(Integer num1, Integer num2) { return num2 - num1; } }); 加入元素：queue.offer()，得到堆顶peek()，弹出堆顶poll() 3，快速排序 public int[] getLeastNumbers(int[] arr, int k) { randomizedSelected(arr, 0, arr.length - 1, k); int[] vec = new int[k]; for (int i = 0; i < k; ++i) { vec[i] = arr[i]; } return vec; } [代码 private vo…]
剑指 Offer 40.最小的k个数
更新于 2022-01-08 21:38
数组中出现次数超过一半的数字（哈希，排序，摩尔投票） 1.哈希表记录频次 先把每个元素加入哈希表，然后遍历所有键值对返回最大键。 2.排序 把数组中所有元素排序，下标是n/2的元素一定是众数。 3.摩尔投票算法 众数为=1,其他-1，加起来和大于0。使用一个候选众数。候选众数遍历获得，每个数都有可能，和为0的时候给候选众数赋值，在这个遍历过程中反复比较候选众数和遍历的数来+-1,进行求和
剑指 Offer 39.数组中出现次数超过一半的数字
更新于 2022-01-08 21:11
反转单词顺序（双指针，内置函数） 1.双指针 倒序遍历字符串，记录单词左右索引边界i,j。 int j = s.length() - 1, i = j;确定单词边界就加到单词列表res（StringBuilder），最后把单词列表拼接成字符串。 s.trim(); // 删除首尾空格 单词根据空格' '来判断，最后转化成字符串返回。 s.substring(i + 1, j + 1)切割字符串成单词。 遇到空格就令j=i res.toString().trim(); / 2.内置函数进行切割 String[] strs = s.trim().split(" "); // 删除首尾空格，分割字符串，剩下的和法1一样都是加到单词列表res里面。
剑指 Offer 58 - I.翻转单词顺序
更新于 2022-01-08 20:47
第一个只出现一次的字符(有序哈希表） 1.哈希表存储频数 对字符串遍历，第一次是将各字符存入哈希表，并存入频数。第二次遍历字符串，发现哈希表中记录的只出现一次的字符就返回。 Map<Character, Integer> frequency = new HashMap<Character, Integer>();记录过程：put(ch, frequency.getOrDefault(ch, 0) + 1)。获取哈希表中值为1的字符：frequency.get(s.charAt(i)) == 1 2.哈希表存储索引 对于每个键值对，键是字符，值是首次出现的索引。第一次出现的记为索引，多次出现的修改为-1，然后遍历哈希表，找出不为-1的所有字符中值最小的就是最先出现的。 3.队列 与法2用同样的哈希，再用一个队列存储，每个字符及第一次出现的位置，对字符串遍历如果遍历到的字符及索引不在哈希中，就作为二元组放入队尾，在就检查是不是只出现一次，也就是存储值是否-1来选择是否弹出队首元素，直到对后元素出现一次或队列为空。 4.数组（和哈希表一个原理） 也可以用一个大小为26的字母数组，第一遍遍历将出现的字母置+1，.第二次遍历，观察对应值是否为1，是就输出。 5.LinkedHashMap 可以存储放入元素的顺序，先遍历字符串获得频率，在遍历map，第一个key对应的键值是1的就返回。 LinkedHashMap<Character, Integer> map = new LinkedHashMap<>();遍历表：for (Character c : map.keySet())，获取键值：get(key) 6.返回空格记得是return ' ';
剑指 Offer 50.第一个只出现一次的字符
更新于 2022-01-08 20:19
使用字符串切片，列表遍历拼接，字符串遍历拼接 1.字符串切片 获取字符串切片s[n:]和s[:n]，用+拼接回来。切片java用s.substring(n,s.length)表示。 2.列表遍历拼接 建一个StringBuilder，记为res，先加入n+1位到末位字符，再加入首位到n位字符，最后转成字符串返回。 StringBuilder res = new StringBuilder(); 3.字符串遍历拼接 建一个string类型的res，把字符拼上去。
剑指 Offer 58 - II.左旋转字符串
更新于 2022-01-08 19:49
把字符串中指定字符替换成另一字符（java中字符串类型string不能直接修改） 1.字符数组 新字符长度是原字符的n倍，就建立长度为字符串n倍的字符数组，从左往右遍历字符串，如果遍历到的字符是要替换的字符，就替换好，如果不是，就存到数组里，要用size变量计数数组内存了几个字符，遍历结束后返回新字符串。 2.使用java的StringBuilder也能实现。 StringBuilder res = new StringBuilder(); s.toCharArray()转字符数组形式可以一个一个输出字符。 StringBuilder res = new StringBuilder(); for(Character c : s.toCharArray())//将字符c一个一个赋值为s的字符 { if(c == ' ') res.append("%20"); else res.append(c); } return res.toString();
剑指 Offer 05.替换空格
更新于 2022-01-06 23:22
在数组中查找2个数，是他们的和正好是所求值（对撞双指针） 1.双指针i,j指向数组左右两端，计算2数和，如果和大于目标，j向左移，如果和小于目标，i向右移，等于时返回。指针相遇时跳出。 2.最后找不到就返回空数组new int[0]; 3.数组很大可以先用二分法缩小范围 4.表示输出数组 new int[] { nums[i], nums[j] }
剑指 Offer 57.和为s的两个数字
更新于 2022-01-06 23:10
反转单词顺序（双指针，内置函数）
1.双指针
倒序遍历字符串，记录单词左右索引边界i,j。 int j = s.length() - 1, i = j;确定单词边界就加到单词列表res（StringBuilder），最后把单词列表拼接成字符串。
s.trim(); // 删除首尾空格
单词根据空格' '来判断，最后转化成字符串返回。
s.substring(i + 1, j + 1)切割字符串成单词。
遇到空格就令j=i
res.toString().trim(); /
2.内置函数进行切割
String[] strs = s.trim().split(" "); // 删除首尾空格，分割字符串，剩下的和法1一样都是加到单词列表res里面。
