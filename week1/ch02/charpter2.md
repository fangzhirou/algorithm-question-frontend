# 1.插入排序
## 1）基本思路：将前j个数构成的子数组排好序，将后面的数从数组中一一遍历，然后插入到已经排好序的子数组中。
## 2）算法实现：将后面的数从右往左依次与前面的子数组进行比较，并且挨个交换位置，直到子数组内的排序是正常的。首先要存储非子数组内遍历到的元素值，然后将该元素和子数组内最左元素比较，排序，由于j要进行循环，所以过程中各种交换都使用i作为媒介表示每一个元素。
## 3）伪代码表示：
for j=2 to n
	key=a[j]
	i=j-1
	while i>0&&a[i]>key
		a[i+1]=a[i]
		i=i-1
	a[i+1]=key

# 2.归并排序
## 1）基本思路：把数组分解成2个子问题，并使用归并排序对子序列进行递归排序，最后把n个已经排好序的子数组合并成一个排序好的数组。分别比较n个子数组中的元素，取较小的放入新数组中，以此类推。
## 2）合并算法实现：将n个子数组分别遍历，比较出小一点的，放在新数组中，然后取出元素的数组就指针后移，和没有后移的数组继续比较，直到有一个数组内的数全部加入新数组中，即露出最后一张哨兵，就把另一个数组剩下的数全部直接加入新数组。
## 3）伪代码表示：
想合并的数组：L[1…n1+1]，R[1…n2+1]
L[n1+1]=R[n2+1]=p（p代表无穷，是哨兵）
合并完成的数组A[]
i=1,j=1
for k=0 to n1+n2
if L[i]<=R[j]
A[K]=L[i]
i=i+1
else 
		A[k]=R[j]
		j=j+1
